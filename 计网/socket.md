<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [假设这样一个场景，客户端在和服务端进行TCP的三次握手的过程中，突然间客户端宕机了，那么这个socket怎么处理？可以删除吗？是怎么删除的？](#%E5%81%87%E8%AE%BE%E8%BF%99%E6%A0%B7%E4%B8%80%E4%B8%AA%E5%9C%BA%E6%99%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9B%E8%A1%8Ctcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%AA%81%E7%84%B6%E9%97%B4%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%95%E6%9C%BA%E4%BA%86%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AAsocket%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%8F%AF%E4%BB%A5%E5%88%A0%E9%99%A4%E5%90%97%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%A0%E9%99%A4%E7%9A%84)
- [在服务端调用accept()之后,socket就是一直可读的吗？就是调用read()函数就一直可以读吗？会阻塞吗？](#%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B0%83%E7%94%A8accept%E4%B9%8B%E5%90%8Esocket%E5%B0%B1%E6%98%AF%E4%B8%80%E7%9B%B4%E5%8F%AF%E8%AF%BB%E7%9A%84%E5%90%97%E5%B0%B1%E6%98%AF%E8%B0%83%E7%94%A8read%E5%87%BD%E6%95%B0%E5%B0%B1%E4%B8%80%E7%9B%B4%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%90%97%E4%BC%9A%E9%98%BB%E5%A1%9E%E5%90%97)
- [如果服务端read()函数发生了阻塞,对方客户端异常关闭了,一直没有发数据过来,服务端会一直阻塞吗？会导致服务端卡死吗？](#%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E7%AB%AFread%E5%87%BD%E6%95%B0%E5%8F%91%E7%94%9F%E4%BA%86%E9%98%BB%E5%A1%9E%E5%AF%B9%E6%96%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%82%E5%B8%B8%E5%85%B3%E9%97%AD%E4%BA%86%E4%B8%80%E7%9B%B4%E6%B2%A1%E6%9C%89%E5%8F%91%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9D%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%9A%E4%B8%80%E7%9B%B4%E9%98%BB%E5%A1%9E%E5%90%97%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8D%A1%E6%AD%BB%E5%90%97)
- [在第七题中提到的这个情况，epoll可以解决这个问题吗？如果要识别这个问题，怎么识别？](#%E5%9C%A8%E7%AC%AC%E4%B8%83%E9%A2%98%E4%B8%AD%E6%8F%90%E5%88%B0%E7%9A%84%E8%BF%99%E4%B8%AA%E6%83%85%E5%86%B5epoll%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E5%90%97%E5%A6%82%E6%9E%9C%E8%A6%81%E8%AF%86%E5%88%AB%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%AF%86%E5%88%AB)
- [linux进程创建线程的流程是怎么样的？](#linux%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84)
  - [Linux进程可以使用pthread库中的函数来创建和管理线程。具体流程如下：](#linux%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8pthread%E5%BA%93%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E5%A6%82%E4%B8%8B)
- [线程享进程的资源在linux中是怎么实现的？](#%E7%BA%BF%E7%A8%8B%E4%BA%AB%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E5%9C%A8linux%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84)
  - [共享虚拟地址空间](#%E5%85%B1%E4%BA%AB%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4)
  - [同步机制](#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6)
- [线程有自己私有的栈，那么这个栈的内存是被分配到哪里的？是放在进程所属的内存里面，还是说放在独立于进程外部的内存中？](#%E7%BA%BF%E7%A8%8B%E6%9C%89%E8%87%AA%E5%B7%B1%E7%A7%81%E6%9C%89%E7%9A%84%E6%A0%88%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E8%A2%AB%E5%88%86%E9%85%8D%E5%88%B0%E5%93%AA%E9%87%8C%E7%9A%84%E6%98%AF%E6%94%BE%E5%9C%A8%E8%BF%9B%E7%A8%8B%E6%89%80%E5%B1%9E%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8C%E9%9D%A2%E8%BF%98%E6%98%AF%E8%AF%B4%E6%94%BE%E5%9C%A8%E7%8B%AC%E7%AB%8B%E4%BA%8E%E8%BF%9B%E7%A8%8B%E5%A4%96%E9%83%A8%E7%9A%84%E5%86%85%E5%AD%98%E4%B8%AD)
- [什么是协程？协程有什么用？](#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%E5%8D%8F%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8)
- [进程的虚拟地址空间](#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4)
- [epoll中可以无限承载socket的连接吗？创建socket时返回值是什么](#epoll%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%97%A0%E9%99%90%E6%89%BF%E8%BD%BDsocket%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%90%97%E5%88%9B%E5%BB%BAsocket%E6%97%B6%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88)
- [select和epoll的区别](#select%E5%92%8Cepoll%E7%9A%84%E5%8C%BA%E5%88%AB)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


# 假设这样一个场景，客户端在和服务端进行TCP的三次握手的过程中，突然间客户端宕机了，那么这个socket怎么处理？可以删除吗？是怎么删除的？

如果客户端在 TCP 三次握手过程中宕机了，服务端将无法收到完整的握手消息，此时服务端会一直等待客户端发送握手消息。为了避免这种情况，可以在服务端设置超时时间，如果在规定时间内没有收到握手消息，就将该 socket 关闭。关闭 socket 的方法是调用 close() 或者 shutdown() 函数。

# 在服务端调用accept()之后,socket就是一直可读的吗？就是调用read()函数就一直可以读吗？会阻塞吗？

在服务端调用 accept() 后，返回的套接字是可读的，但不一定一直可读。此时可以使用 select()、poll() 或 epoll() 等函数来检测套接字上是否有数据可读。如果套接字没有数据可读，则一般情况下会阻塞，直到有数据可读或者超时。

# 如果服务端read()函数发生了阻塞,对方客户端异常关闭了,一直没有发数据过来,服务端会一直阻塞吗？会导致服务端卡死吗？

如果服务端的 read() 函数发生阻塞，而对方客户端异常关闭了，一般情况下服务端会一直阻塞，直到发生超时或者其他异常情况。为了避免这种问题，可以设置非阻塞式 I/O，或者使用 select()、poll() 或 epoll() 等函数来监控套接字状态，并在发现异常情况时及时处理。

# 在第七题中提到的这个情况，epoll可以解决这个问题吗？如果要识别这个问题，怎么识别？

可以使用 epoll 来解决上述问题。在 epoll 中，可以设置超时时间和错误标志位，当超时或者发生错误时，可以及时关闭 socket。

#  linux进程创建线程的流程是怎么样的？

## Linux进程可以使用pthread库中的函数来创建和管理线程。具体流程如下：

- 通过调用pthread_create()函数创建线程。
- 操作系统为新线程分配资源，包括栈空间、程序计数器等。
- 将新线程加入到进程的线程池中进行管理。


# 线程享进程的资源在linux中是怎么实现的？

Linux中实现线程共享进程资源的方式有两种：共享虚拟地址空间和使用同步机制。

## 共享虚拟地址空间
Linux中的线程共享进程的虚拟地址空间，也就是说所有线程都能够访问进程的全局变量和堆区内存。

## 同步机制
Linux中的线程共享进程的同步对象，例如信号量、互斥锁、条件变量等。这些同步对象可以保护共享资源，确保多个线程不会同时修改共享资源。


# 线程有自己私有的栈，那么这个栈的内存是被分配到哪里的？是放在进程所属的内存里面，还是说放在独立于进程外部的内存中？

Linux中的线程栈内存在进程的虚拟地址空间中。当线程被创建时，操作系统会为每个线程分配一块私有的栈空间，这个栈空间在进程的虚拟地址空间中被分配。不同线程之间的栈空间是独立的，互相不会干扰。

# 什么是协程？协程有什么用？

协程是一种用户态线程，也被称为轻量级线程。协程可以在同一个线程内部进行切换，而不像普通线程需要通过系统调用切换上下文，因此协程具有轻量、高效、灵活等特点。

协程的主要用途是解决IO密集型应用程序中的并发问题，如网络编程、Web服务器等。通过使用协程，可以避免大量线程之间频繁切换上下文的开销，提高应用程序的并发性能。同时，协程可以简化编程模型，使得代码更易于编写和维护。

# 进程的虚拟地址空间

进程的虚拟地址空间是一个抽象的概念，它代表了进程所能访问到的内存地址范围。在现代操作系统中，每个进程都有自己独立的虚拟地址空间，这样可以保证每个进程之间的内存空间相互隔离，互不干扰。

虚拟地址空间包含了进程的所有内存区域，包括：

代码段：存放可执行程序代码的部分。
数据段：存放已经初始化的全局变量和静态变量等。
BSS段：存放未初始化的全局变量和静态变量等。
堆区：用于动态分配内存，通常使用malloc()等函数从堆区申请内存。
栈区：用于存储函数调用时的局部变量、参数以及函数返回值等。
进程的虚拟地址空间为每个进程提供了一个独立的内存空间，在该空间内，每个进程都可以按照自己的需要对内存进行读写操作，而不会影响到其他进程的内存空间。

# epoll中可以无限承载socket的连接吗？创建socket时返回值是什么

在 epoll 中，可以支持非常高的并发连接，理论上可以承载无限量的 socket 连接，但实际上会受到系统资源的限制。同时需要注意的是，在支持大量连接时，还需要考虑网络带宽、CPU 和内存等方面的问题。

创建 socket 时，如果成功则返回一个新的文件描述符，用于后续的操作，如果失败则返回 -1。在使用 epoll 监听时，需要将这个文件描述符加入到 epoll 实例的事件列表中，以便检测该 socket 上的事件。加入事件列表时，需要指定要监听的事件类型和相关参数，并且可以设置一些选项，例如 ET/LT 模式和边缘触发/水平触发等。

总之，在处理大量连接的情况下，使用 epoll 可以更好地管理和监控套接字的状态和事件，提高网络应用程序的性能和可伸缩性。

# select和epoll的区别

select 和 epoll 都是在网络编程中用于检测套接字上事件的函数，它们有以下区别：

1. 数据结构不同： select 函数使用 fd_set 作为描述符集合参数，而 epoll 函数使用 epoll_event 结构体数组作为描述符集合参数。
2. 效率不同： 在处理大量连接时，select 的效率很低。因为每次调用 select 函数时都需要将所有的监视对象从用户空间复制到内核空间，这样会发生大量的内存和 CPU 负载。而 epoll 可以避免这个问题，并可以显著提高效率。
3. 可伸缩性不同： epoll 支持 ET（边缘触发）模式，而 select 不支持。ET 模式下，只有当 IO 事件发生时，才会触发一次通知；而 LT（水平触发）模式则在 IO 事件未被处理时反复触发通知。ET 模式对于大规模连接情况的网络应用更有优势。
4. 限制不同： select 限制最大监视文件描述符的数量，通常为 1024；而 epoll 则没有这个限制。


因此，在处理大规模连接情况的网络应用中，推荐使用 epoll。