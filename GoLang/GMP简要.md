# GMP分别是什么，分别有多少数量？
G：goroutine，go的协程，每个go关键字都会创建一个协程
M：machine，工作线程，在Go中称为Machine，数量对应真实的CPU数
P：process，包含运行Go代码所需要的必要资源，用来调度G和M之间的关联关系，其数量可以通过GOMAXPROCS来设置，默认为核心数

线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P 的本地队列为空时，M 也会尝试从全局队列或其他 P 的本地队列获取 G。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。

# Goroutine调度策略
1. 队列轮转：P会周期性的将G调度到M中执行，执行一段时间后，保存上下文，将G放到队列尾部，然后从队列中再取出一个G进行调度，P还会周期性的查看全局队列是否有G等待调度到M中执行
2. 系统调用：当G0即将进入系统调用时，M0将释放P，进而某个空闲的M1获取P，继续执行P队列中剩下的G。M1的来源有可能是M的缓存池，也可能是新建的。
3. 当G0系统调用结束后，如果有空闲的P，则获取一个P，继续执行G0。如果没有，则将G0放入全局队列，等待被其他的P调度。然后M0将进入缓存池睡眠。
# Groutine的切换时机

1. select操作阻塞时  
2. io阻塞  
3. 阻塞在channel  
4. 程序员显示编码操作  
5. 等待锁  
6. 程序调用

# Context原理
context在很大程度上利用了通道在close时会通知所有监听它的协程这一特性来实现。每一个派生出的子协程都会创建一个新的退出通道，组织好context之间的关系即可实现继承链上退出的传递。

context使用场景：

1. RPC调用
2. PipeLine
3. 超时请求
4. HTTP服务器的request互相传递数据
# golang内存对齐机制
为了能让CPU可以更快的存取到各个字段，Go编译器会帮你把struct结构体做数据的对齐。所谓的数据对齐，是指内存地址是所存储数据大小（按字节为单位）的整数倍，以便CPU可以一次将该数据从内存中读取出来。编译器通过在结构体的各个字段之间填充一些空白已达到对齐的目的。

不同硬件平台占用的大小和对齐值都可能是不一样的，每个特定平台上的编译器都有自己的默认“对齐系数”，32位系统对齐系数是4，64位系统对齐系数是8
不同类型的对齐系数也可能不一样，使用Go 语言中的unsafe.Alignof函数可以返回相应类型的对齐系数，对齐系数都符合2^n这个规律，最大也不会超过8

对齐原则：

1.结构体变量中成员的偏移量必须是成员变量大小和成员对齐系数两者最小值的整数倍
2.整个结构体的地址必须是最大字节和编译器默认对齐系数两者最小值的整数倍（结构体的内存占用是1/4/8/16 byte...）
3.struct{}放在结构体中间不进行对齐，放在结构体最后一个字段则要根据最大字节和编译器默认对齐系数两者最小值
来进行字段对齐
1
2
3
4
type T2 struct{
	i8 int8
	i64 int64
	i32 int32
}

type T3 struct{
	i8 int8
	i32 int32
	i64 int64
}
