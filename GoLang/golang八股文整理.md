# 进程、线程、协程

>[golang八股文整理（持续搬运）_golang面试八股文-CSDN博客](https://blog.csdn.net/qq_43716830/article/details/124405506)

进程：资源分配和CPU调度的基本单位

线程：CPU调度的基本单位，线程除了有一些自己的必要的堆栈空间之外，其它的资源都是共享的线程中的，共享的资源包括：

```
1.所有线程共享相同的虚拟地址空间，即它们可以访问同样的代码段、数据段和堆栈段。
2.文件描述符：进程打开的文件描述符是进程级别的资源，所以同一个进程中的线程可以共享打开的文件描述符，这意味着它们可以同时读写同一个文件。
3.全局变量：全局变量是进程级别的变量，因此可以被同一个进程中的所有线程访问和修改。
4.静态变量：静态变量也是进程级别的变量，在同一个进程中的线程之间共享内存空间。
5.进程ID、进程组ID
```

独占的资源：

```
1、线程ID
2、寄存器组的值
3、线程堆栈
4、错误返回码
5、信号屏蔽码
6、线程的优先级
```

协程：用户态的线程，可以通过用户程序创建、删除。协程切换时不需要切换内核态。

## 协程与线程的区别：

```
1.线程是操作系统的概念，而协程是程序级的概念。线程由操作系统调度执行，每个线程都有自己的执行上下文，包
括程序计数器、寄存器等。而协程由程序自身控制。
2.多个线程之间通过切换执行的方式实现并发。线程切换时需要保存和恢复上下文，涉及到上下文切换的开销。而协
程切换时不需要操作系统的介入，只需要保存和恢复自身的上下文，切换开销较小。
3.线程是抢占式的并发，即操作系统可以随时剥夺一个线程的执行权。而协程是合作式的并发，协程的执行权由程序
自身决定，只有当协程主动让出执行权时，其他协程才会得到执行机会。
```

## 线程的优点

```
1.创建一个新线程的代价要比创建一个新进程小的多
2.线程之间的切换相较于进程之间的切换需要操作系统做的工作很少
3.线程占用的资源要比进程少很多
4.能充分利用多处理器的可并行数量
5.等待慢速 IO操作结束以后，程序可以执行其他的计算任务
```

## 缺点：

1. 性能损失（ 一个计算密集型线程是很少被外部事件阻塞的，无法和其他线程共享同一个处理器，当计算密集型的线程的数量比可用的处理器多，那么就有可能有很大的性能损失，这里的性能损失是指增加了额外的同步和调度开销，二可用资源不变。）
2. 健壮性降低（线程之间是缺乏保护性的。在一个多线程程序里，因为时间上分配的细微差距或者是共享了一些不应该共享的变量而造成不良影响的可能影响是很大的。）
3. 缺乏访问控制（ 因为进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响 。）
4. 编程难度提高（编写和 调试一个多线程程序比单线程困难的多。）

## 有栈协程和无栈协程

- 有栈协程：把局部变量放入到新开的空间上，golang的实现，类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核
- 无栈协程：直接把局部变量放入系统栈上，js、c++、rust那种await、async实现，主要原理就是闭包+异步，换句话说，其实就是协程的上下文都放到公共内存中，协程切换时，使用状态机来切换，就不用切换对应的上下文了，因为都在堆里的。比有栈协程都要轻量许多。
# Goroutine调度策略
1. 队列轮转：P会周期性的将G调度到M中执行，执行一段时间后，保存上下文，将G放到队列尾部，然后从队列中再取出一个G进行调度，P还会周期性的查看全局队列是否有G等待调度到M中执行
2. 系统调用：当G0即将进入系统调用时，M0将释放P，进而某个空闲的M1获取P，继续执行P队列中剩下的G。M1的来源有可能是M的缓存池，也可能是新建的。
3. 当G0系统调用结束后，如果有空闲的P，则获取一个P，继续执行G0。如果没有，则将G0放入全局队列，等待被其他的P调度。然后M0将进入缓存池睡眠。
# Groutine的切换时机

1. select操作阻塞时  
2. io阻塞  
3. 阻塞在channel  
4. 程序员显示编码操作  
5. 等待锁  
6. 程序调用

# Context原理
context在很大程度上利用了通道在close时会通知所有监听它的协程这一特性来实现。每一个派生出的子协程都会创建一个新的退出通道，组织好context之间的关系即可实现继承链上退出的传递。

context使用场景：

1. RPC调用
2. PipeLine
3. 超时请求
4. HTTP服务器的request互相传递数据
# golang内存对齐机制
为了能让CPU可以更快的存取到各个字段，Go编译器会帮你把struct结构体做数据的对齐。所谓的数据对齐，是指内存地址是所存储数据大小（按字节为单位）的整数倍，以便CPU可以一次将该数据从内存中读取出来。编译器通过在结构体的各个字段之间填充一些空白已达到对齐的目的。

不同硬件平台占用的大小和对齐值都可能是不一样的，每个特定平台上的编译器都有自己的默认“对齐系数”，32位系统对齐系数是4，64位系统对齐系数是8
不同类型的对齐系数也可能不一样，使用Go 语言中的unsafe.Alignof函数可以返回相应类型的对齐系数，对齐系数都符合2^n这个规律，最大也不会超过8

## 对齐原则：

1. 结构体变量中成员的偏移量必须是成员变量大小和成员对齐系数两者最小值的整数倍
2. 整个结构体的地址必须是最大字节和编译器默认对齐系数两者最小值的整数倍（结构体的内存占用是1/4/8/16 byte...）
3. struct{}放在结构体中间不进行对齐，放在结构体最后一个字段则要根据最大字节和编译器默认对齐系数两者最小值来进行字段对齐
```
type C struct {
	a struct{}
	b int64
	c int64
}

type D struct {
	a int64
	b struct{}
	c int64
}

type E struct {
	a int64
	b int64
	c struct{}
}

type F struct {
	a int32
	b int32
	c struct{}
}

func main() {
	fmt.Println(unsafe.Sizeof(C{})) // 16
	fmt.Println(unsafe.Sizeof(D{})) // 16
	fmt.Println(unsafe.Sizeof(E{})) // 24
  	fmt.Println(unsafe.Sizeof(F{})) // 12
}
```



# golang中new和make的区别？

`var`声明值类型的变量时，系统会默认为他分配内存空间，并赋该类型的零值
如果是指针类型或者引用类型的变量，系统不会为它分配内存，默认是`nil`。

1. `make` 仅用来分配及初始化类型为 `slice`、`map`、`chan` 的数据。
2. `new` 可分配任意类型的数据，根据传入的类型申请一块内存，返回指向这块内存的指针，即类型 `Type`。
3. `make` 返回引用，即 `Type`，`new` 分配的空间被清零， `make` 分配空间后，会进行初始。
4. `make`函数返回的是`slice`、`map`、`chan`类型本身
5. `new`函数返回一个指向该类型内存地址的指针
# Golang中，array和slice的区别
注意：Go的slice不是线程安全的。
切片是基于数组实现的，底层是数组，可以理解为对底层数组的抽象

1) 数组长度不同
- 数组初始化必须指定长度，并且长度就是固定的
- 切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大
2) 函数传参不同
- 数组是值类型，将一个数组赋值给另一个数组时，传递的是一份深拷贝，函数传参操作都会复制整个数组数据，会占用额外的内存，函数内对数组元素值的修改，不会修改原数组内容。
- 切片是引用类型，将一个切片赋值给另一个切片时，传递的是一份浅拷贝，函数传参操作不会拷贝整个切片，只会复制len和cap，底层共用同一个数组，不会占用额外的内存，函数内对数组元素值的修改，会修改原数组内容。

3) 计算数组长度方式不同
- 数组需要遍历计算数组长度，时间复杂度为O(n)
- 切片底层包含len字段，可以通过len计算切片长度，时间复杂度为O(1)

# Golang的map特点

Go中的map是一个指针，占用8个字节，指向hmap结构体，map底层是基于哈希表+链地址法存储的。

map的特点：

```
1.键不能重复
2.键必须可哈希（目前我们已学的数据类型中，可哈希的有：int/bool/float/string/array）
3.无序
```

## Golang的map为什么是无序的？
使用range多次遍历map时输出的key和vabue 的顺序可能不同。这是Go语言的设计者们有意为之，旨在提示开发者们，Go底层实现并不保证map遍历顺序稳定，请大家不要依赖range遍历结果顺序

主要原因有2点:

1. map在遍历时，并不是从固定的0号bucket开始遍历的，每次遍历，都会从一个随机值序号的bucket，再从其中随机的cell开始遍历
2. map遍历时，是按序遍历bucket，同时按序遍历bucket中和其overflow bucket中的cell。但是map在扩容后，会发生key的搬迁，这造成原来落在一个buket中的Key,搬迁后，有可能会落到其他bucket中了，从这个角度看，遍历map的结果就不可能是按照原来的顺序了

map本身是无序的，且遍历时顺序还会被随机化，如果想顺序遍历map，需要对 map key先排序，再按照key 的顺序遍历map。

## Map的负载因子是6.5？

什么是负载因子?

```
负载因子(load factor)，用于衡量当前哈希表中空间占用率的核心指标，也就是每个bucket桶存储的平均	元素个数。
负载因子=哈希表存储的元素个数/桶个数
```

# Channel
## Channel是同步的还是异步的？
Channel是异步进行的, channel存在3种状态：

1. nil，未初始化的状态，只进行了声明，或者手动赋值为nil
2. active，正常的channel，可读或者可写
3. closed，已关闭，千万不要误认为关闭channel后，channel的值是nil，对已关闭channel读写都会panic

## Channel死锁场景
1. 非缓存channel只写不读
2. 非缓存channel读在写后面
3. 缓存channel写入超过缓冲区数量
4. 空读
5. 多个协程相互等待

# 空 struct{} 占用空间么？用途是什么？
空结构体 struct{} 实例不占据任何的内存空间。

用途：
1.将 map 作为集合(Set)使用时，可以将值类型定义为空结构体，仅作为占位符使用即可。
2.不发送数据的信道(channel)
使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。
3.结构体只包含方法，不包含任何的字段

golang值接收者和指针接收者的区别
golang函数与方法的区别是，方法有一个接收者。

如果方法的接收者是指针类型，无论调用者是对象还是对象指针，修改的都是对象本身，会影响调用者

如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者